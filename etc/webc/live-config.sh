#!/bin/bash
# Setting up Webconverger system as root user
. /etc/webc/functions.sh
. /etc/webc/webc.conf

cmdline_has debug && set -x

sub_literal() {
  awk -v str="$1" -v rep="$2" '
  BEGIN {
    len = length(str);
  }

  (i = index($0, str)) {
    $0 = substr($0, 1, i-1) rep substr($0, i + len);
  }

  1'
}

process_options()
{

cmdline_has timezone && /etc/init.d/timezone # process timezone=

# Create a Webconverger preferences to store dynamic FF options
cat > "$prefs" <<EOF
// This file is autogenerated based on cmdline options by live-config.sh. Do
// not edit this file, your changes will be overwriting on the next reboot!

EOF

# If printing support is not installed, prevent printing dialogs from being
# shown
if ! dpkg -s cups 2>/dev/null >/dev/null; then
	echo '// Print support not included, disable print dialogs' >> "$prefs"
	echo 'pref("print.always_print_silent", true);' >> "$prefs"
	echo 'pref("print.show_print_progress", false);' >> "$prefs"
fi

for x in $( cmdline ); do
	case $x in

	debug)
		echo "webc ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
		;;

	chrome=*)
		chrome=${x#chrome=}
		dir="/etc/webc/extensions/${chrome}"
		test -d $dir && {
			test -e "$link" && rm -f "$link"
			logs "switching chrome to ${chrome}"
			ln -s "$dir" "$link"
		}
		;;

	locale=*)
		locale=${x#locale=}
		echo "pref(\"general.useragent.locale\", \"${locale}\");" >> "$prefs"
		echo "pref(\"intl.accept_languages\", \"${locale}, en\");" >> "$prefs"
		;;

	cron=*)
		cron="$( echo ${x#cron=} | sed 's,%20, ,g' )"		
		cat <<EOC > /etc/cron.d/live-config
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
$cron
EOC
		;;

	homepage=*)
		homepage="$( echo ${x#homepage=} | sed 's,%20, ,g' )"
		echo "browser.startup.homepage=$(echo $homepage | awk '{print $1}')" > /opt/firefox/defaults/preferences/homepage.properties
		;;
	esac
done

if ! cmdline_has noclean
then
cat >> "$prefs" <<EOF
// Enable private browsing and enable all sanitize on shutdown features just
// to be sure we are wiping the slate clean.
pref("privateBrowsingEnabled", true);
pref("browser.privatebrowsing.autostart", true);
pref("privacy.sanitize.sanitizeOnShutdown", true);
pref("privacy.clearOnShutdown.offlineApps", true);
pref("privacy.clearOnShutdown.passwords", true);
pref("privacy.clearOnShutdown.siteSettings", true);
// cpd = Clear Private Data
pref("privacy.cpd.offlineApps", true);
pref("privacy.cpd.passwords", true);
pref("privacy.sanitize.sanitizeOnShutdown", true);
EOF
fi

# Make sure /home has noexec and nodev, for extra security.
# First, just try to remount, in case /home is already a separate filesystem
# (when using persistence, for example).
mount -o remount,noexec,nodev /home 2>/dev/null || (
	# Turn /home into a tmpfs. We use a trick here: after the mount, this
	# subshell will still have the old /home as its current directory, so
	# we can still read the files in the original /home. By passing -C to
	# the second tar invocation, it does a chdir, which causes it to end
	# up in the new filesystem. This enables us to easily copy the
	# existing files from /home into the new tmpfs.
	cd /home
	mount -o noexec,nodev -t tmpfs tmpfs /home
	tar -c . | tar -x -C /home
)

stamp=$( git show $webc_version | grep '^Date')

test -f ${link}/content/about.xhtml.bak || cp ${link}/content/about.xhtml ${link}/content/about.xhtml.bak
cat ${link}/content/about.xhtml.bak |
sub_literal 'OS not running' "${webc_version} ${stamp}" |
sub_literal 'var aboutwebc = "";' "var aboutwebc = \"$(echo ${install_qa_url} | sed 's,&,&amp;,g')\";" > ${link}/content/about.xhtml

} # end of process_options

git_repo="/live/image/live/filesystem.git"

update_cmdline() {
	# Get the revision we're currently running as given on the
	# cmdline. Get it now, so we can be sure it's taken from
	# /proc/cmdline, not /etc/webc/cmdline.
	current_git_revision=$(cmdline_get git-revision)

	# If no git-revision was given on the commandline, default to HEAD
	[ -n "$current_git_revision" ] || current_git_revision=$(git --git-dir "${git_repo}" rev-parse HEAD)

	# If we have a "cached" version of the configuration on disk,
	# copy that to /etc/webc, so we can compare the new version with
	# it to detect changes and/or use it in case the new download
	# fails.
	if [ -e "/live/image/live/webc-cmdline" ]; then
		cp /live/image/live/webc-cmdline /etc/webc/cmdline
	else
		touch /etc/webc/cmdline
	fi

	SECONDS=0
	while true
	do
		wget --timeout=5 -t 1 -q -O /etc/webc/cmdline.tmp "$config_url" && break
		test $? = 8 && break # 404
		test $SECONDS -gt 15 && break
		logs "Failed to download configuration, trying again..."
		sleep 1
	done

	# A configuration file always has an fetch-revision
	if ! [ -e "/etc/webc/cmdline.tmp" ] || ! grep -qs fetch-revision /etc/webc/cmdline.tmp; then
		# No (valid) file downloaded, just keep running with
		# what we have
		logs "Failed to download (valid) configuration, using existing config"
		return
	fi

	# Apply the new config
	mv /etc/webc/cmdline.tmp /etc/webc/cmdline

	# Try to make /live/image writable
	mount -o remount,rw /live/image
	# mount always returns success, so we use touch to see if this
	# worked.
	if ! touch /live/image; then
		# /live/image could not be made writable (e.g. booting
		# from an iso fs), so just use the new config downloaded
		# and skip all the other stuff below
		logs "Not a writable boot medium, skipping upgrade check"
		return
	fi


	if ! cmdline_has noupdates; then
		# See to what we should be updating. fetch_revision is
		# the revision we should fetch from the git server (it
		# can only be a branch or tag name, since we can't fetch
		# a sha directly).
		# update_revision is optional and can be used to specify
		# a sha of a revision to update to (but it must be
		# "included" in the fetch triggered by fetch_revision).
		# If no update_revision is given, the revision specified
		# by fetch_revision is used.
		#
		# Note that there is a third revision parameter,
		# git_revision, which must always contain a sha and must
		# only be used on the real kernel cmdline in the
		# bootloader config to tell the initrd which revision to
		# mount. It is automatically generated below based on
		# fetch_revision / update_revision.
		fetch_revision=$(cmdline_get fetch-revision)
		update_revision=$(cmdline_get update-revision)

		logs "Fetching git revision ${fetch_revision}"

		# Fetch the git revision. It will not be stored
		# in any local branch, just in FETCH_HEAD.
		rm -f /.git/FETCH_HEAD
		if ! git --git-dir "${git_repo}" fetch --quiet origin "${fetch_revision}" ||
		   ! git --git-dir "${git_repo}" rev-parse --verify --quiet FETCH_HEAD; then
			# Fetching the revision failed, to prevent an
			# unbootable system, bail out now. Since we're not
			# updating /live/image/live/webc-cmdline, this will be
			# retried after the next reboot.
			logs "Fetching git revision ${fetch_revision} failed"
			return
		fi

		if [ -z "$(git --git-dir "${git_repo}" tag --contains FETCH_HEAD)" ]; then
			# If there is no tag that contains the
			# downloaded revision yet, create one. Keeping a
			# tag for every revision downloaded allows git
			# fetch to not download these revisions again
			# (since it does not take into account all
			# commit objects in the repository, only named
			# refs when telling the server what we already
			# have).
			git tag "fetched-${fetch_revision}-$(date '+%s')" FETCH_HEAD

			# TODO: Clean up tag list by removing tags that
			# are reachable from other tags / FETCH_HEAD
			# already?
		fi

		# Get the sha has of the latest revision we just fetched
		fetched_revision=$(git --git-dir "${git_repo}" rev-parse FETCH_HEAD)
		logs "Successfully fetched git revision (got ${fetched_revision})"

		if [ -z "${update_revision}" ]; then
			git_revision="${fetched_revision}"
			logs "Trying update to latest revision fetched (${git_revision})"
		elif git --git-dir "${git_repo}" rev-parse --verify --quiet "${update_revision}"; then
			# Get the canonical sha hash
			git_revision="$(git --git-dir "${git_repo}" rev-parse "${update_revision}")"
			logs "Trying update to specific revision (${git_revision})"
		else
			logs "Invalid update_revision (${update_revision}), skipping upgrade"
			return
		fi


		# TODO: Also enter this if when boot_params was changed
		if [ "${current_git_revision}" != "${git_revision}" ]; then
			# The config says we should be running a different
			# revision than we're currently running, so change our
			# bootloader config to make sure that happens.

			if [ -f /live/image/boot/live.cfg.in ]; then
				# This is the "live" version, which
				# offers a boot menu
				if ! generate_live_config /live/image "${git_repo}" "${git_revision}"; then
					logs "Updating bootloader config failed!"
					return
				fi
			else
				# This is the "installed" version, which
				# does not show a boot prompt and just
				# boots the default entry
				if ! generate_installed_config /live/image "${git_repo}" "${git_revision}"; then
					logs "Updating bootloader config failed!"
					return
				fi
			fi

			logs "Updated bootloader to boot from ${git_revision}"
		else
			logs "Already running ${current_git_revision}, no upgrade needed"
		fi
	else
		logs "noupdates given, skipping upgrade check"

	fi

	# Copy the cmdline outside to a persistent spot, in case we
	# can't reach the config server on next boot and to allow
	# detecting changes in the config.
	cp /etc/webc/cmdline /live/image/live/webc-cmdline
}

wait_for $live_config_pipe 2>/dev/null

. "/etc/webc/webc.conf"
cmdline_has noconfig || update_cmdline
process_options

echo ACK > $live_config_pipe

# live-config should restart via inittab and get blocked 
# until $live_config_pipe is re-created
